use crate::ScriptManifest;
use crate::generator::Generator;
use std::fmt::Write;
use std::collections::HashMap;
use chrono::Utc;

pub struct KotlinNativeGenerator;

impl Generator for KotlinNativeGenerator {
    fn generate(&self, manifest: &ScriptManifest) -> anyhow::Result<String> {
        let mut output = String::new();
        let local_time = Utc::now();
        writeln!(
            output,
            "// Auto-generated by dropbear-engine with the magna-carta parser on {} UTC",
            local_time.format("%Y-%m-%d %H:%M:%S")
        )?;
        writeln!(
            output,
            "@file:OptIn(ExperimentalForeignApi::class, ExperimentalNativeApi::class)"
        )?;
        writeln!(output)?;

        writeln!(output, "package com.dropbear.decl")?;
        writeln!(output)?;

        writeln!(output, "import com.dropbear.DropbearEngine")?;
        writeln!(output, "import com.dropbear.EntityId")?;
        writeln!(output, "import com.dropbear.EntityRef")?;
        writeln!(output, "import com.dropbear.System")?;
        writeln!(output, "import com.dropbear.ffi.NativeEngine")?;
        writeln!(output, "import kotlinx.cinterop.COpaquePointer")?;
        writeln!(output, "import kotlinx.cinterop.ExperimentalForeignApi")?;
        writeln!(output, "import kotlin.experimental.ExperimentalNativeApi")?;
        writeln!(output, "import kotlin.native.CName")?;
        writeln!(output)?;

        let mut imported_classes = Vec::new();
        for item in manifest.items() {
            if let Some(last_dot) = item.fqcn().rfind('.') {
                let package = &item.fqcn()[..last_dot];
                let simple_name = &item.fqcn()[last_dot + 1..];
                writeln!(output, "import {}.{}", package, simple_name)?;
                imported_classes.push(simple_name.to_string());
            } else {
                imported_classes.push(item.simple_name().to_string());
            }
        }
        writeln!(output)?;

        let mut tag_map: HashMap<String, Vec<String>> = HashMap::new();
        for item in manifest.items() {
            let simple_name = item.simple_name();
            if item.tags().is_empty() {
                continue;
            }
            for tag in item.tags() {
                tag_map.entry(tag.clone()).or_default().push(simple_name.to_string());
            }
        }

        writeln!(output, "private fun getScriptFactories(tag: String): List<() -> System> {{")?;
        writeln!(output, "    return when (tag) {{")?;

        for (tag, classes) in &tag_map {
            let factories: Vec<String> = classes
                .iter()
                .map(|cls| format!("{{ {}() }}", cls))
                .collect();
            writeln!(
                output,
                "        \"{}\" -> listOf({})",
                tag,
                factories.join(", ")
            )?;
        }

        writeln!(output, "        else -> emptyList()")?;
        writeln!(output, "    }}")?;
        writeln!(output, "}}")?;
        writeln!(output)?;

        writeln!(
            output,
            "private fun getDropbearEngine(worldPointer: COpaquePointer?): DropbearEngine {{"
        )?;
        writeln!(output, "    val nativeEngine = NativeEngine()")?;
        writeln!(output, "    nativeEngine.init(worldPointer)")?;
        writeln!(output, "    return DropbearEngine(nativeEngine)")?;
        writeln!(output, "}}")?;
        writeln!(output)?;

        for (func_name, method_name) in [
            ("dropbear_load", "load"),
            ("dropbear_update", "update"),
            ("dropbear_destroy", "destroy"),
        ] {
            let param_extra = if method_name == "update" {
                ", deltaTime: Double"
            } else {
                ""
            };
            let call_extra = if method_name == "update" {
                ", deltaTime.toFloat()"
            } else {
                ""
            };

            writeln!(output, "@CName(\"{}\")", func_name)?;
            writeln!(
                output,
                "fun {}ScriptByTag(worldPointer: COpaquePointer?, currentEntity: Long?, tag: String?{}) {{",
                method_name,
                param_extra
            )?;
            writeln!(output, "    if (tag == null) return")?;
            writeln!(output, "    val factories = getScriptFactories(tag)")?;
            writeln!(
                output,
                "    val engine = getDropbearEngine(worldPointer)"
            )?;
            writeln!(output, "    for (factory in factories) {{")?;
            writeln!(output, "        val script = factory()")?;
            if method_name == "update" {
                writeln!(output, "        script.{}(engine{})", method_name, call_extra)?;
            } else {
                writeln!(output, "        script.{}(engine)", method_name)?;
            }
            writeln!(output, "    }}")?;
            writeln!(output, "}}")?;
            writeln!(output)?;
        }

        Ok(output)
    }
}