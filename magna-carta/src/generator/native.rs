use crate::ScriptManifest;
use crate::generator::Generator;
use chrono::Utc;
use std::collections::HashMap;
use std::fmt::Write;

pub struct KotlinNativeGenerator;

impl Generator for KotlinNativeGenerator {
    fn generate(&self, manifest: &ScriptManifest) -> anyhow::Result<String> {
        let mut output = String::new();
        let local_time = Utc::now();
        writeln!(
            output,
            "// Auto-generated by dropbear-engine with the magna-carta parser on {} UTC",
            local_time.format("%Y-%m-%d %H:%M:%S")
        )?;
        writeln!(
            output,
            "@file:OptIn(ExperimentalForeignApi::class, ExperimentalNativeApi::class)"
        )?;
        writeln!(output, "@file:Suppress(\"UNUSED_PARAMETER\", \"unused\")")?;
        writeln!(output)?;

        writeln!(output, "package com.dropbear.decl")?;
        writeln!(output)?;

        writeln!(
            output,
            r#"
import com.dropbear.DropbearEngine
import com.dropbear.System
import com.dropbear.ffi.NativeEngine
import com.dropbear.logging.Logger
import kotlinx.cinterop.COpaquePointer
import kotlinx.cinterop.ExperimentalForeignApi
import kotlin.experimental.ExperimentalNativeApi
        "#
        )?;
        writeln!(output)?;

        let mut imported_classes = Vec::new();
        for item in manifest.items() {
            if let Some(last_dot) = item.fqcn().rfind('.') {
                let package = &item.fqcn()[..last_dot];
                let simple_name = &item.fqcn()[last_dot + 1..];
                writeln!(output, "import {}.{}", package, simple_name)?;
                imported_classes.push(simple_name.to_string());
            } else {
                imported_classes.push(item.simple_name().to_string());
            }
        }
        writeln!(output)?;

        let mut tag_map: HashMap<String, Vec<String>> = HashMap::new();
        for item in manifest.items() {
            let simple_name = item.simple_name();
            if item.tags().is_empty() {
                continue;
            }
            for tag in item.tags() {
                tag_map
                    .entry(tag.clone())
                    .or_default()
                    .push(simple_name.to_string());
            }
        }

        writeln!(
            output,
            r#"
object ScriptManager {{
    private var dropbearEngine: DropbearEngine? = null
    private val scriptsByTag: MutableMap<String, MutableList<System>> = mutableMapOf()

    fun init(worldPtr: COpaquePointer?, inputPtr: COpaquePointer?, graphicsPtr: COpaquePointer?) : Int {{
        try {{
            val nativeEngine = NativeEngine()
            nativeEngine.init(worldPtr, inputPtr, graphicsPtr)
            dropbearEngine = DropbearEngine(nativeEngine)

            scriptsByTag.clear()
            Logger.debug("Native ScriptManager initialised")
            return 0
        }} catch (e: Exception) {{
            Logger.error("Native ScriptManager failed to initialise: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun loadSystemsByTag(tag: String): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            val factories = getScriptFactories(tag)
            val instances = factories.map {{ it() }}

            for (instance in instances) {{
                instance.load(engine)
            }}

            scriptsByTag.getOrPut(tag) {{ mutableListOf() }}.addAll(instances)
            Logger.debug("Loaded ${{instances.size}} script(s) for tag: '$tag'")
            return 0
        }} catch (e: Exception) {{
            Logger.error("Error loading systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun updateAllSystems(dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            for (instances in scriptsByTag.values) {{
                for (instance in instances) {{
                    instance.update(engine, dt)
                }}
            }}
            return 0
        }} catch (e: Exception) {{
            Logger.error("Error updating all systems: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun updateSystemsByTag(tag: String, dt: Float): Int {{
        val engine = dropbearEngine ?: return -2
        try {{
            val instances = scriptsByTag[tag] ?: emptyList()
            for (instance in instances) {{
                instance.update(engine, dt)
            }}
            return 0
        }} catch (e: Exception) {{
            Logger.error("Error updating systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun destroyByTag(tag: String): Int {{
        try {{
            val engine = dropbearEngine ?: return -2
            val instances = scriptsByTag[tag] ?: emptyList()
            for (instance in instances) {{
                instance.destroy(engine)
            }}
            scriptsByTag.remove(tag)
            Logger.debug("Destroyed ${{instances.size}} script(s) for tag: '$tag'")
            return 0
        }} catch (e: Exception) {{
            Logger.error("Error destroying systems for tag '$tag': ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}

    fun destroyAll(): Int {{
        try {{
            val engine = dropbearEngine ?: return -2
            for (instances in scriptsByTag.values) {{
                for (instance in instances) {{
                    instance.destroy(engine)
                }}
            }}
            scriptsByTag.clear()
            dropbearEngine = null
            return 0
        }} catch (e: Exception) {{
            Logger.error("Error destroying scripts: ${{e.message}}")
            e.printStackTrace()
            return -1
        }}
    }}
            "#
        )?;
        // getScriptFactories (generated)
        {
            writeln!(
                output,
                "  private fun getScriptFactories(tag: String): List<() -> System> {{"
            )?;
            writeln!(output, "       return when (tag) {{")?;

            for (tag, classes) in &tag_map {
                let factories: Vec<String> = classes
                    .iter()
                    .map(|cls| format!("{{ {}() }}", cls))
                    .collect();
                writeln!(
                    output,
                    "           \"{}\" -> listOf({})",
                    tag,
                    factories.join(", ")
                )?;
            }

            writeln!(output, "           else -> emptyList()")?;
            writeln!(output, "        }}")?;
            writeln!(output, "  }}")?;
            writeln!(output)?;
        }

        writeln!(output, "}}")?;

        writeln!(
            output,
            r#"
@CName("dropbear_init")
fun dropbear_native_init(worldPtr: COpaquePointer?, inputStatePtr: COpaquePointer?, graphicsPtr: COpaquePointer?): Int {{
    return ScriptManager.init(worldPtr, inputStatePtr, graphicsPtr)
}}


@CName("dropbear_load_tagged")
fun dropbear_load_systems_for_tag(tag: String?): Int {{
    if (tag == null) return -1
    return ScriptManager.loadSystemsByTag(tag)
}}

@CName("dropbear_update_all")
fun dropbear_update_all_systems(dt: Float): Int {{
    return ScriptManager.updateAllSystems(dt)
}}

@CName("dropbear_update_tagged")
fun dropbear_update_systems_for_tag(tag: String?, dt: Float): Int {{
    if (tag == null) return -1
    return ScriptManager.updateSystemsByTag(tag, dt)
}}

@CName("dropbear_destroy_tagged")
fun dropbear_destroy(tag: String?): Int {{
    if (tag == null) return -1
    return ScriptManager.destroyByTag(tag)
}}

@CName("dropbear_destroy_all")
fun dropbear_destroy_all(): Int {{
    return ScriptManager.destroyAll()
}}
        "#
        )?;

        Ok(output)
    }
}
